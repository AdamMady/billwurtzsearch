<!doctype html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>questions</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    /* sample-style colors and tags */
    dco { color:#E9EC54; }
    rco { color:#ff6600; }
    qco { color:#B387FF; }
    green { color: #00cc00; }
    blue { color: #5555ff; }
    white { color: #000000; }
    lightred { color: #ff6666; }
    strike { text-decoration: line-through; }
    red { color: #ff4444; }
    yellow { color:#ffff00; }
    lightgreen { color:#b3ffb3; }

    quotequestion {
      margin:20px;
      padding:5px;
      display:block;
      background-color:#444;
      border:1px solid black;
    }
    quotedco { color:#e9ec54; }
    quoteqco { color:#b387ff; }
    quoteaco { color:#ffffff; font-weight:normal; }

    body {
      margin:0;
      padding:10px;
      background-color:#323232;
      color:#ffffff;
      font-family:"Times New Roman", Times, serif;
      font-size:15px;
      line-height:1.3;
      word-wrap:break-word;
    }
    a { color:#00FF00; text-decoration:none; }
    a:visited { color:#67FF79; }
    h1 { font-weight:normal; margin:0 0 .5em; }
    .alignright { float:right; }
    .alignleft { float:left; }

    /* search bar similar minimal */
    #search-container {
      margin:0 0 1em;
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
    }
    #search-bar {
      flex:1;
      min-width:220px;
      padding:6px 8px;
      font-size:14px;
      border:1px solid #555;
      background:#222;
      color:#fff;
      border-radius:2px;
      font-family:"Times New Roman", Times, serif;
      box-sizing:border-box;
    }
    #results-info {
      margin-top:6px;
      font-style:italic;
      color:#ccc;
    }

    /* question-answer block */
    .question-item {
      margin-bottom:2em;
    }
    mark {
      background-color:#E9EC54;
      color:#000;
      padding:1px 2px;
      border-radius:2px;
    }

    @media (max-width: 900px) {
      #search-container { flex-direction: column; }
    }
  </style>
</head>

<body>

  <span class="alignright">
    <form action="random.php">
      <input type="submit" value="i'm feeling randy" style="background-color:black; color:red; font-size:8px; width:85px;">
    </form>
  </span>

  <h1>ue<font color="#00EE3B">q</font>stions</h1>

  <div id="search-container">
    <input type="search" id="search-bar" placeholder="search through space and time..." aria-label="search questions">
    <div id="results-info">Loading archive...</div>
  </div>

  <div id="results-container"></div>
  <div id="loading-indicator" style="display:none; font-style:italic; margin-top:4px;">Loading more...</div>

  <script>
    // configuration
    const DATA_BASE_URL = './data/'; // where manifest.json and JSON chunks live
    let manifestFiles = [];
    let searchableFiles = []; // new: chunked searchable list from manifest.searchable
    let allItems = [];        // items loaded via display chunking
    let searchableItems = null; // array when loaded
    let loadedIndex = 0;
    let loading = false;
    let fullLoadedForSearch = false; // used only if searchableFiles not present
    let searchActive = false;

    const searchBar = document.getElementById('search-bar');
    const resultsContainer = document.getElementById('results-container');
    const resultsInfo = document.getElementById('results-info');
    const loadingIndicator = document.getElementById('loading-indicator');

    function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function getTextFromHTML(html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return (temp.textContent || '').replace(/\s+/g,' ').trim();
    }

    function renderBatch(items, highlight = '') {
      const frag = document.createDocumentFragment();
      items.forEach(item => {
        const wrapper = document.createElement('div');
        wrapper.className = 'question-item';
        let html = item.html;

        if (highlight) {
          const q = highlight.trim();
          if (q.length > 0) {
            const escaped = escapeRegExp(q);
            const re = new RegExp(escaped, 'gi');
            html = html.replace(re, m => `<mark>${m}</mark>`);
          }
        }

        wrapper.innerHTML = html;
        frag.appendChild(wrapper);
      });
      resultsContainer.appendChild(frag);
    }

    async function loadManifest() {
      try {
        const resp = await fetch(`${DATA_BASE_URL}manifest.json`);
        if (!resp.ok) throw new Error('manifest fetch failed');
        const j = await resp.json();
        manifestFiles = Array.isArray(j.files) ? j.files : [];
        searchableFiles = Array.isArray(j.searchable) ? j.searchable : [];
      } catch (e) {
        console.error(e);
        resultsInfo.textContent = 'Failed to load manifest.';
      }
    }

    async function loadNextChunk() {
      if (loading) return;
      if (loadedIndex >= manifestFiles.length) {
        resultsInfo.textContent = `All ${allItems.length.toLocaleString()} questions loaded.`;
        return;
      }
      loading = true;
      loadingIndicator.style.display = 'block';
      try {
        const name = manifestFiles[loadedIndex];
        const resp = await fetch(`${DATA_BASE_URL}${name}`);
        if (!resp.ok) throw new Error('chunk load failed');
        const arr = await resp.json();
        allItems.push(...arr);
        if (!searchActive) renderBatch(arr, '');
        loadedIndex++;
        resultsInfo.textContent = searchActive
          ? `${document.querySelectorAll('.question-item').length.toLocaleString()} matching results`
          : `Showing ${allItems.length.toLocaleString()} questions...`;
      } catch (e) {
        console.error(e);
        resultsInfo.textContent = 'Error loading chunk.';
      } finally {
        loading = false;
        loadingIndicator.style.display = 'none';
      }
    }

    async function loadAllForSearchFallback() {
      if (fullLoadedForSearch) return;
      resultsInfo.textContent = 'Loading full archive for search...';
      loadingIndicator.style.display = 'block';
      loading = true;
      const remaining = manifestFiles.slice(loadedIndex);
      try {
        // load sequentially to be nicer to the server
        for (const n of remaining) {
          const r = await fetch(`${DATA_BASE_URL}${n}`);
          const c = await r.json();
          allItems.push(...c);
        }
        fullLoadedForSearch = true;
        loadedIndex = manifestFiles.length;
      } catch (e) {
        console.error(e);
        resultsInfo.textContent = 'Failed to load full archive.';
      } finally {
        loading = false;
        loadingIndicator.style.display = 'none';
      }
    }

    async function loadSearchableIfNeeded() {
      if (searchableItems) return; // already loaded
      if (searchableFiles && searchableFiles.length > 0) {
        try {
          resultsInfo.textContent = 'Loading search index...';
          loadingIndicator.style.display = 'block';
          // load sequentially to avoid huge parallel bursts
          const all = [];
          for (const f of searchableFiles) {
            const r = await fetch(`${DATA_BASE_URL}${f}`);
            if (!r.ok) throw new Error(`failed ${f}`);
            const a = await r.json();
            if (Array.isArray(a)) all.push(...a);
          }
          // normalize: ensure plainText exists
          searchableItems = all.map(it => {
            if (!it.plainText) {
              return { html: it.html, plainText: getTextFromHTML(it.html).toLowerCase() };
            }
            return it;
          });
          resultsInfo.textContent = `Search index ready (${searchableItems.length.toLocaleString()} items).`;
        } catch (e) {
          console.warn('Could not load chunked searchable index:', e.message);
          searchableItems = null;
        } finally {
          loadingIndicator.style.display = 'none';
        }
      } else {
        // legacy fallback: try single searchable.json if present
        try {
          const r = await fetch(`${DATA_BASE_URL}searchable.json`);
          if (!r.ok) throw new Error('no single searchable.json');
          const a = await r.json();
          searchableItems = a.map(it => {
            if (!it.plainText) {
              return { html: it.html, plainText: getTextFromHTML(it.html).toLowerCase() };
            }
            return it;
          });
          resultsInfo.textContent = `Search index ready (${searchableItems.length.toLocaleString()} items).`;
        } catch {
          searchableItems = null;
        }
      }
    }

    function doSearch(term) {
      const q = term.toLowerCase().trim();
      if (!q) {
        searchActive = false;
        resultsContainer.innerHTML = '';
        renderBatch(allItems);
        resultsInfo.textContent = `Showing ${allItems.length.toLocaleString()} questions...`;
        return;
      }
      searchActive = true;
      const start = performance.now();
      let filtered = [];
      if (searchableItems) {
        filtered = searchableItems.filter(item => item.plainText.includes(q));
      } else {
        // fallback if no separate index
        filtered = allItems.filter(item => {
          if (!item.plainText) {
            item.plainText = getTextFromHTML(item.html).toLowerCase();
          }
          return item.plainText.includes(q);
        });
      }
      const duration = Math.round(performance.now() - start);
      resultsContainer.innerHTML = '';
      renderBatch(filtered, q);
      resultsInfo.textContent = `${filtered.length.toLocaleString()} results in ${duration}ms.`;
    }

    const debouncedSearch = (() => {
      let timeout;
      return function (val) {
        clearTimeout(timeout);
        timeout = setTimeout(() => doSearch(val), 200);
      };
    })();

    window.addEventListener('scroll', () => {
      if (searchActive) return;
      if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 400) {
        loadNextChunk();
      }
    });

    searchBar.addEventListener('input', async (e) => {
      const v = e.target.value;
      // prefer loading dedicated search index first (if available)
      if (!searchableItems) {
        await loadSearchableIfNeeded();
      }
      if (!searchableItems && !fullLoadedForSearch) {
        // fallback only if no searchable index exists
        await loadAllForSearchFallback();
      }
      debouncedSearch(v);
    });

    (async function init() {
      await loadManifest();
      if (manifestFiles.length === 0) {
        resultsInfo.textContent = 'No data.';
        return;
      }
      // start display chunking
      await loadNextChunk();
      setTimeout(() => loadNextChunk(), 500);

      // OPTIONAL: warm-load search index in background (comment out if too heavy)
      // loadSearchableIfNeeded();
    })();
  </script>
</body>
</html>
